/* 216554588 Navarro Rizo Bruno Octavio
   212554346 Duron Gonzalez Jonathan
   Estructuras de Datos II  D12
   Lara Lopez Graciela */

#include <iostream>
#include <fstream>
#include <sstream>
#include <conio.h>

using namespace std;

///Funcion para rellenar un arreglo de caracteres con espacios
void rellenar(char arr[],int lon) {
    for(int i = 0; i < lon; i++) {
        arr[i] = ' ';
        }
    }

///Funcion para reescribir los espacios vacios del arreglo
void escribir(char arr[], string str, int lon) {
    for(unsigned int i = 0; i < str.length(); i++) {
        arr[i] = str[i];
        }
        ///Aqui agregamos los separadores de campo
        if(lon > 3)
        arr[lon-1] = ',';
    }

///Funcion para imprimir arreglos
string imprimir(char arr[],int lon, bool flag) {
    stringstream res;
    if(flag == true){
        for(int i = 0; i < lon; i++) {
        cout << arr[i];
        }
    }
    else{
        for(int i = 0; i < lon; i++) {
        res << arr[i];
        }
    }


    return res.str();
    }

/**Definicion de la struct del producto, usaremos este objeto para
    guardar la informacion del inventario, lo manejamos con arreglos
    para que sean de longitud fija, pero tambien strings para manejarlo
    mas facil*/

struct Prod {
    char codigoC[15];
    char nombreC[15];
    char fabricanteC[15];
    char cantidadC[6];
    char diaC[4];
    char mesC[10];
    char viaC[15];
    char dirC[3];

    ///Variables auxiliares
    string codigoS;
    string nombreS;
    string fabricanteS;
    string cantidadS;
    string diaS;
    string mesS;
    string viaS;
    string dirS;
    };

int main() {

    /**Creamos un arreglo de 51 productos, ya que no
    utilizaremos el indice 0. En este arreglo almacenaremos
    nuestros productos*/
    Prod arr[51];

    /**Creamos una instancia Prod, que nos ayudara
    para guardar cada linea*/
    Prod miProd;

    ///Menu
    int op;
    do {
        system("cls");
        cout << endl << "1) Ejecutar y mostrar en pantalla" << endl << "2) Salir"
             << endl <<"Opcion:    _";
        cin >> op;

        switch(op) {

            ///Ordenamos e imprimimos
            case 1: {
                system("cls");

                ///Creamos y abrimos nuestro archivo de lectura
                ifstream archivo;
                archivo.open("Inventario1.txt",ios::in);

                /**Ind nos dira cual es el indice del arreglo donde
                guardaremos el producto.
                aux solo es un auxiliar*/
                int ind, aux;

                ///Llenamos el arreglo de espacios
                for(int i = 1; i < 51; i++){
                    arr[i].nombreS = " ";

                ///Rellenamos arreglo con espacio vacio
                    rellenar(arr[i].codigoC,sizeof(arr[i].codigoC));
                    rellenar(arr[i].nombreC,sizeof(arr[i].nombreC));
                    rellenar(arr[i].fabricanteC,sizeof(arr[i].fabricanteC));
                    rellenar(arr[i].cantidadC,sizeof(arr[i].cantidadC));
                    rellenar(arr[i].diaC,sizeof(arr[i].diaC));
                    rellenar(arr[i].mesC,sizeof(arr[i].mesC));
                    rellenar(arr[i].viaC,sizeof(arr[i].viaC));
                    rellenar(arr[i].dirC,sizeof(arr[i].dirC));
                }


                /**Leemos cada linea del inventario y lo guardamos en cada
                campo de miProd, gracias al separador de campo (','), hacemos
                esto hasta que se encuentre un salto de linea, lo cual indica que
                se salta al siguiente registro.
                Tambien, agregamos la coma al final de cada campo, para poder
                reutilizarla como separador*/
                while(!archivo.eof()) {

                    ///Rellenamos miProd con espacio vacio
                    rellenar(miProd.codigoC,sizeof(miProd.codigoC));
                    rellenar(miProd.nombreC,sizeof(miProd.nombreC));
                    rellenar(miProd.fabricanteC,sizeof(miProd.fabricanteC));
                    rellenar(miProd.cantidadC,sizeof(miProd.cantidadC));
                    rellenar(miProd.diaC,sizeof(miProd.diaC));
                    rellenar(miProd.mesC,sizeof(miProd.mesC));
                    rellenar(miProd.viaC,sizeof(miProd.viaC));
                    rellenar(miProd.dirC,sizeof(miProd.dirC));

                    getline(archivo,miProd.codigoS, ',');
                    //miProd.codigoS += ',';

                    getline(archivo,miProd.nombreS, ',');
                    //miProd.nombreS += ',';

                    getline(archivo,miProd.fabricanteS, ',');
                    //miProd.fabricanteS += ',';

                    getline(archivo,miProd.cantidadS, ',');
                    //miProd.cantidadS += ',';

                    getline(archivo,miProd.diaS, ',');
                    //miProd.diaS += ',';

                    getline(archivo,miProd.mesS, ',');
                    //miProd.mesS += ',';

                    getline(archivo,miProd.viaS, ',');
                    //miProd.viaS += ',';

                    getline(archivo,miProd.dirS, '\n');

                    ///Hasta este punto tenemos una instancia de un producto con todos sus campos

                    ///Convertimos a entero el campo liga
                    ind = stoi(miProd.dirS);
                    ///Guardamos la direccion en el auxiliar
                    aux = ind;

                    /**Si el arreglo esta ocupado en el indice que queremos ingresar un nuevo
                    dato, el indice incrementa hasta encontrar un lugar vacio, esta comparacion
                    la realizamos buscando el espacio en blanco con el que llenamos el arreglo*/
                    while(arr[ind].nombreS != " ") {
                        ind++;

                        ///Si el indice se sobrepasa de 50, regresa al 1
                        if(ind > 50)
                            ind = 1;
                        }

                    ///Cambiamos el campo liga del producto a insertar, para que apunte a nulo
                    miProd.dirS = "-1";
                    escribir(miProd.dirC,miProd.dirS,sizeof(miProd.dirC));

                    /**Con este condicional evaluamos si existe mas de una colision, en cuyo caso
                    cambiamos el valor de aux*/
                    if(arr[aux].dirS != "-1") {
                        stringstream intValue(arr[aux].dirS);
                        intValue >> aux;
                        }

                    /**Cambiamos el campo liga del elemento que ocupa el espacio, para que apunte al
                    nuevo elemento*/
                    arr[aux].dirS = to_string(ind);
                    rellenar(arr[aux].dirC,sizeof(arr[aux].dirC));
                    escribir(arr[aux].dirC,to_string(ind),sizeof(arr[aux].dirC));

                    ///Sobreescribimos miProd
                    escribir(miProd.codigoC,miProd.codigoS,sizeof(miProd.codigoC));
                    escribir(miProd.nombreC,miProd.nombreS,sizeof(miProd.nombreC));
                    escribir(miProd.fabricanteC,miProd.fabricanteS,sizeof(miProd.fabricanteC));
                    escribir(miProd.cantidadC,miProd.cantidadS,sizeof(miProd.cantidadC));
                    escribir(miProd.diaC,miProd.diaS,sizeof(miProd.diaC));
                    escribir(miProd.mesC,miProd.mesS,sizeof(miProd.mesC));
                    escribir(miProd.viaC,miProd.viaS,sizeof(miProd.viaC));

                    ///Guardamos el producto en el lugar que le corresponde
                    arr[ind] = miProd;
                    }

                ///Cerramos el archivo
                archivo.close();

                ///Ciclos para la impresion de datos
                for(int i = 1; i < 51; i++) {
                    if(i < 10) {
                        cout << "0" << i << " ";
                        imprimir(arr[i].codigoC,sizeof(arr[i].codigoC),true);
                        imprimir(arr[i].nombreC,sizeof(arr[i].nombreC),true);
                        imprimir(arr[i].fabricanteC,sizeof(arr[i].fabricanteC),true);
                        imprimir(arr[i].cantidadC,sizeof(arr[i].cantidadC),true);
                        imprimir(arr[i].diaC,sizeof(arr[i].diaC),true);
                        imprimir(arr[i].mesC,sizeof(arr[i].mesC),true);
                        imprimir(arr[i].viaC,sizeof(arr[i].viaC),true);
                        imprimir(arr[i].dirC,sizeof(arr[i].dirC),true);
                        cout << endl;
                        }
                    else {
                        cout << i << " ";
                        imprimir(arr[i].codigoC,sizeof(arr[i].codigoC),true);
                        imprimir(arr[i].nombreC,sizeof(arr[i].nombreC),true);
                        imprimir(arr[i].fabricanteC,sizeof(arr[i].fabricanteC),true);
                        imprimir(arr[i].cantidadC,sizeof(arr[i].cantidadC),true);
                        imprimir(arr[i].diaC,sizeof(arr[i].diaC),true);
                        imprimir(arr[i].mesC,sizeof(arr[i].mesC),true);
                        imprimir(arr[i].viaC,sizeof(arr[i].viaC),true);
                        imprimir(arr[i].dirC,sizeof(arr[i].dirC),true);
                        cout << endl;
                        }
                    }

                cout << endl << endl;
                system("pause");
                }
            break;

            ///Escribimos el archivo y salimos del programa
            case 2: {
                system("cls");

                ///Archivo de salida
                ofstream archivoS;
                archivoS.open("HASH_SAT_PRO.txt",ios::out);

                for(int i = 1; i < 51; i++) {
                    if(i < 10) {
                        archivoS << "0" << i << " ";
                        archivoS << imprimir(arr[i].codigoC,sizeof(arr[i].codigoC),false);
                        archivoS << imprimir(arr[i].nombreC,sizeof(arr[i].nombreC),false);
                        archivoS << imprimir(arr[i].fabricanteC,sizeof(arr[i].fabricanteC),false);
                        archivoS << imprimir(arr[i].cantidadC,sizeof(arr[i].cantidadC),false);
                        archivoS << imprimir(arr[i].diaC,sizeof(arr[i].diaC),false);
                        archivoS << imprimir(arr[i].mesC,sizeof(arr[i].mesC),false);
                        archivoS << imprimir(arr[i].viaC,sizeof(arr[i].viaC),false);
                        archivoS << imprimir(arr[i].dirC,sizeof(arr[i].dirC),false);
                        archivoS << endl;
                        }
                    else {
                        archivoS << i << " ";
                        archivoS << imprimir(arr[i].codigoC,sizeof(arr[i].codigoC),false);
                        archivoS << imprimir(arr[i].nombreC,sizeof(arr[i].nombreC),false);
                        archivoS << imprimir(arr[i].fabricanteC,sizeof(arr[i].fabricanteC),false);
                        archivoS << imprimir(arr[i].cantidadC,sizeof(arr[i].cantidadC),false);
                        archivoS << imprimir(arr[i].diaC,sizeof(arr[i].diaC),false);
                        archivoS << imprimir(arr[i].mesC,sizeof(arr[i].mesC),false);
                        archivoS << imprimir(arr[i].viaC,sizeof(arr[i].viaC),false);
                        archivoS << imprimir(arr[i].dirC,sizeof(arr[i].dirC),false);
                        archivoS << endl;
                        }
                    }

                archivoS.close();
                system("cls");
                cout << endl << endl << endl << "\t\t\tGracias por usar el programa :)" << endl << endl << endl;
                exit(1);
                }
            break;

            default:
                cout << endl << "Opcion invalida" << endl << endl;
                system("pause");
                break;
            }
        }
    while(true);
    }
